<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Wave Packet</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            margin: 0; overflow: hidden;
            background: linear-gradient(135deg, #000000 0%, #0a0a1e 50%, #000000 100%);
            color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #container { width: 100vw; height: 100vh; display: block; }
        #projections {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 15px; z-index: 10;
        }
        .projection-view {
            width: 200px; height: 150px;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 10px; overflow: visible;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            position: relative;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            cursor: help;
        }
        .projection-view:hover {
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 6px 24px rgba(100, 150, 255, 0.4);
        }
        .projection-view canvas { width: 100%; height: 100%; display: block; }
        .projection-label {
            position: absolute; top: 5px; left: 8px;
            font-size: 11px; color: #88ccff; font-weight: 600;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
            pointer-events: none; z-index: 1;
        }
        .tooltip {
            position: absolute; right: 220px; top: 0;
            width: 280px; padding: 15px;
            background: rgba(10, 10, 30, 0.95); backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 10px;
            font-size: 12px; line-height: 1.6; color: #aabbcc;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 100;
        }
        .tooltip strong {
            color: #88ccff; display: block; margin-bottom: 8px;
            font-size: 13px;
        }
        .projection-view:hover .tooltip {
            opacity: 1;
        }
        @media (max-width: 1200px) {
            .tooltip { display: none; }
        }
        @media (max-width: 768px) {
            #projections { display: none; }
        }
        #info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(15px);
            padding: 20px; border-radius: 12px;
            font-size: 14px; line-height: 1.6; z-index: 10; max-width: 480px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
        }
        #info code {
            font-family: 'Courier New', monospace; font-size: 15px;
            color: #88ccff; display: block;
            background: rgba(0, 100, 200, 0.1); padding: 12px;
            border-radius: 8px; margin-bottom: 12px;
            border-left: 3px solid #4488ff;
        }
        #info .label { color: #aabbcc; font-size: 13px; margin-bottom: 8px; }
        #info .controls {
            color: #6688aa; font-size: 11px; margin-top: 12px;
            padding-top: 12px; border-top: 1px solid rgba(100, 150, 255, 0.2);
        }
        @media (max-width: 768px) {
            #info { font-size: 12px; padding: 16px; max-width: calc(100vw - 40px); }
            #info code { font-size: 13px; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="projections">
        <div class="projection-view" data-tooltip="side">
            <div class="projection-label">Side View (XY)</div>
            <canvas id="sideCanvas"></canvas>
            <div class="tooltip">
                <strong>Side View (XY Plane)</strong><br>
                Shows the real component oscillating up and down. This is what you'd see if you looked at the wave from the side - a classic sine wave with a Gaussian envelope (peaks are highest in the middle, fade at edges).
            </div>
        </div>
        <div class="projection-view" data-tooltip="end">
            <div class="projection-label">End View (YZ)</div>
            <canvas id="endCanvas"></canvas>
            <div class="tooltip">
                <strong>End View (YZ Plane)</strong><br>
                Looking through the wave from one end, you see a circular pattern. The real (Y) and imaginary (Z) components trace out circles, showing the wave's rotation in complex space. The envelope makes it look like nested circles.
            </div>
        </div>
        <div class="projection-view" data-tooltip="top">
            <div class="projection-label">Top View (XZ)</div>
            <canvas id="topCanvas"></canvas>
            <div class="tooltip">
                <strong>Top View (XZ Plane)</strong><br>
                Shows the imaginary component oscillating forward and back. This is 90¬∞ out of phase with the side view, demonstrating the complex nature of the quantum wave function.
            </div>
        </div>
        <div class="projection-view" data-tooltip="phase">
            <div class="projection-label">Phase Spectrum</div>
            <canvas id="phaseCanvas"></canvas>
            <div class="tooltip">
                <strong>Phase Visualization</strong><br>
                Colors represent the wave's phase: œÜ = kx - œât. As the phase cycles from 0 to 2œÄ, colors flow through the spectrum (red ‚Üí yellow ‚Üí green ‚Üí cyan ‚Üí blue ‚Üí magenta ‚Üí red). This shows where each point is in its oscillation cycle and is crucial for quantum interference.
            </div>
        </div>
    </div>
    
    <div id="info">
        <code>Œ®(x,t) = A¬∑exp[-(x-vt)¬≤/4œÉ¬≤]¬∑exp[i(kx-œât)]</code>
        <div class="label">
            Gaussian wave packet with space-time warping visualization.
            The 3D helix shows real and imaginary components while the grid warps with the probability density.
        </div>
        <div class="controls">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-drag to pan</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>

    <script>
        const { EffectComposer, RenderPass, UnrealBloomPass } = THREE;
        let scene, camera, renderer, controls, composer, clock;
        let waveLine, lineGeometry, gridMesh, gridGeometry;
        let sideCtx, endCtx, topCtx, phaseCtx;

        const N_POINTS = 1500;
        const X_MIN = -40, X_MAX = 40, X_RANGE = X_MAX - X_MIN;
        const VELOCITY = 8.0, WAVENUMBER = 2.5, TIME_SCALE = 0.7;
        
        // Smooth cycling parameters instead of linear growth
        const AMPLITUDE_BASE = 2.0, AMPLITUDE_CYCLE_PERIOD = 25, AMPLITUDE_CYCLE_AMOUNT = 0.3;
        const WIDTH_BASE = 1.5, WIDTH_CYCLE_PERIOD = 20, WIDTH_CYCLE_AMOUNT = 0.4;
        const FREQ_BASE = WAVENUMBER * VELOCITY, FREQ_CYCLE_PERIOD = 18, FREQ_CYCLE_AMOUNT = 2.0;
        
        const GRID_SIZE = X_RANGE * 1.3, GRID_SEGMENTS = 60;
        const GRID_Y_POS = -4.0, MAX_WARP_DEPTH = 2.0, WARP_WIDTH_SCALE = 1.8;

        const wavePositions = new Float32Array(N_POINTS * 3);
        const waveColors = new Float32Array(N_POINTS * 3);
        let originalGridVertices = [];

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            
            // Setup 2D projection canvases
            const sideCanvas = document.getElementById('sideCanvas');
            const endCanvas = document.getElementById('endCanvas');
            const topCanvas = document.getElementById('topCanvas');
            const phaseCanvas = document.getElementById('phaseCanvas');
            
            sideCanvas.width = 400;
            sideCanvas.height = 300;
            endCanvas.width = 400;
            endCanvas.height = 300;
            topCanvas.width = 400;
            topCanvas.height = 300;
            phaseCanvas.width = 400;
            phaseCanvas.height = 300;
            
            sideCtx = sideCanvas.getContext('2d');
            endCtx = endCanvas.getContext('2d');
            topCtx = topCanvas.getContext('2d');
            phaseCtx = phaseCanvas.getContext('2d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 20, 45);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x505070, 0.6));
            const light1 = new THREE.DirectionalLight(0x6688ff, 0.8);
            light1.position.set(20, 30, 20);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xff6688, 0.5);
            light2.position.set(-20, 20, -20);
            scene.add(light2);

            // Wave line
            lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(wavePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(waveColors, 3));
            const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
            waveLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(waveLine);

            // Grid
            gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);
            gridGeometry.rotateX(-Math.PI / 2);
            gridGeometry.translate(0, GRID_Y_POS, 0);

            const gridPosAttr = gridGeometry.attributes.position;
            for (let i = 0; i < gridPosAttr.count; i++) {
                originalGridVertices.push(new THREE.Vector3().fromBufferAttribute(gridPosAttr, i));
            }

            const gridMaterial = new THREE.MeshStandardMaterial({
                color: 0x3366cc, wireframe: true, roughness: 0.7, metalness: 0.3,
                transparent: true, opacity: 0.6, emissive: 0x112244, emissiveIntensity: 0.3
            });
            gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
            scene.add(gridMesh);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 15;
            controls.maxDistance = 120;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 1.4, 0.6, 0.3
            ));

            updateWavePacket(0);
            updateGrid(0);
            window.addEventListener('resize', onWindowResize, false);
        }

        function smoothCycle(time, period, amount) {
            return amount * Math.sin(2 * Math.PI * time / period);
        }

        function getEffectiveCenter(time) {
            const unwrappedCenter = VELOCITY * time;
            const offset = unwrappedCenter - X_MIN;
            const wrappedOffset = ((offset % X_RANGE) + X_RANGE) % X_RANGE;
            return X_MIN + wrappedOffset;
        }

        function updateWavePacket(time) {
            const posArray = wavePositions;
            const colorArray = waveColors;

            // Smooth cycling parameters
            const current_A = AMPLITUDE_BASE + smoothCycle(time, AMPLITUDE_CYCLE_PERIOD, AMPLITUDE_CYCLE_AMOUNT);
            const current_a = WIDTH_BASE + smoothCycle(time, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const current_omega = FREQ_BASE + smoothCycle(time, FREQ_CYCLE_PERIOD, FREQ_CYCLE_AMOUNT);
            const a_sq = current_a * current_a;
            const tempColor = new THREE.Color();
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < N_POINTS; i++) {
                const x = X_MIN + X_RANGE * (i / (N_POINTS - 1));
                
                // Smooth wrapping distance
                let dx = x - effective_center_x;
                if (Math.abs(dx) > X_RANGE / 2) {
                    dx = dx > 0 ? dx - X_RANGE : dx + X_RANGE;
                }

                const envelope = Math.exp(-(dx * dx) / (4 * a_sq));
                const phase = WAVENUMBER * x - current_omega * time;
                const realPart = Math.cos(phase);
                const imagPart = Math.sin(phase);

                const idx3 = i * 3;
                posArray[idx3] = x;
                posArray[idx3 + 1] = current_A * envelope * realPart;
                posArray[idx3 + 2] = current_A * envelope * imagPart;

                const hue = ((phase / (2 * Math.PI)) % 1.0 + 1) % 1.0;
                tempColor.setHSL(hue, 1.0, 0.65);
                colorArray[idx3] = tempColor.r;
                colorArray[idx3 + 1] = tempColor.g;
                colorArray[idx3 + 2] = tempColor.b;
            }

            lineGeometry.attributes.position.needsUpdate = true;
            lineGeometry.attributes.color.needsUpdate = true;
            lineGeometry.computeBoundingSphere();
        }

        function updateGrid(time) {
            const gridPosArray = gridGeometry.attributes.position.array;
            const current_a = WIDTH_BASE + smoothCycle(time, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const warp_width_sq = Math.pow(current_a * WARP_WIDTH_SCALE, 2);
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < originalGridVertices.length; i++) {
                const originalPos = originalGridVertices[i];
                const vertexX = originalPos.x;

                // Smooth wrapping distance
                let dx = vertexX - effective_center_x;
                if (Math.abs(dx) > X_RANGE / 2) {
                    dx = dx > 0 ? dx - X_RANGE : dx + X_RANGE;
                }

                const distSq = dx * dx;
                const warpFactor = Math.exp(-distSq / warp_width_sq);
                const warpY = -MAX_WARP_DEPTH * warpFactor;

                const idx = i * 3;
                gridPosArray[idx] = originalPos.x;
                gridPosArray[idx + 1] = originalPos.y + warpY;
                gridPosArray[idx + 2] = originalPos.z;
            }

            gridGeometry.attributes.position.needsUpdate = true;
            gridGeometry.computeVertexNormals();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function draw2DProjections() {
            const posArray = wavePositions;
            const colorArray = waveColors;
            
            // Clear canvases
            sideCtx.fillStyle = '#000';
            sideCtx.fillRect(0, 0, 400, 300);
            endCtx.fillStyle = '#000';
            endCtx.fillRect(0, 0, 400, 300);
            topCtx.fillStyle = '#000';
            topCtx.fillRect(0, 0, 400, 300);
            
            // Draw grid lines
            const drawGrid = (ctx) => {
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 40, 0);
                    ctx.lineTo(i * 40, 300);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * 30);
                    ctx.lineTo(400, i * 30);
                    ctx.stroke();
                }
            };
            drawGrid(sideCtx);
            drawGrid(endCtx);
            drawGrid(topCtx);
            
            // Draw center lines
            const drawCenterLines = (ctx) => {
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, 150);
                ctx.lineTo(400, 150);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(200, 0);
                ctx.lineTo(200, 300);
                ctx.stroke();
            };
            drawCenterLines(sideCtx);
            drawCenterLines(endCtx);
            drawCenterLines(topCtx);
            
            // Scale factors for visualization
            const xScale = 400 / X_RANGE;
            const yScale = 60;
            const zScale = 60;
            
            // Side view (XY) - shows oscillating wave with Gaussian envelope
            sideCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const y = posArray[idx + 1];
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const screenY = 150 - y * yScale;
                
                if (i === 0) sideCtx.moveTo(screenX, screenY);
                else sideCtx.lineTo(screenX, screenY);
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                sideCtx.strokeStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
            }
            sideCtx.lineWidth = 2;
            sideCtx.stroke();
            
            // End view (YZ) - shows circular/coroidal pattern
            endCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const y = posArray[idx + 1];
                const z = posArray[idx + 2];
                
                const screenX = 200 + z * zScale;
                const screenY = 150 - y * yScale;
                
                if (i === 0) endCtx.moveTo(screenX, screenY);
                else endCtx.lineTo(screenX, screenY);
            }
            endCtx.strokeStyle = '#88ccff';
            endCtx.lineWidth = 2;
            endCtx.stroke();
            
            // Draw points to show the circular pattern better
            for (let i = 0; i < N_POINTS; i += 20) {
                const idx = i * 3;
                const y = posArray[idx + 1];
                const z = posArray[idx + 2];
                
                const screenX = 200 + z * zScale;
                const screenY = 150 - y * yScale;
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                
                endCtx.fillStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
                endCtx.beginPath();
                endCtx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                endCtx.fill();
            }
            
            // Top view (XZ) - shows another oscillating wave
            topCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const z = posArray[idx + 2];
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const screenY = 150 - z * zScale;
                
                if (i === 0) topCtx.moveTo(screenX, screenY);
                else topCtx.lineTo(screenX, screenY);
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                topCtx.strokeStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
            }
            topCtx.lineWidth = 2;
            topCtx.stroke();
            
            // Phase spectrum view - shows color flow across the wave
            phaseCtx.fillStyle = '#000';
            phaseCtx.fillRect(0, 0, 400, 300);
            drawGrid(phaseCtx);
            
            // Draw phase as a color gradient strip
            const stripHeight = 80;
            const stripY = 110;
            
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const envelope = Math.sqrt(posArray[idx + 1] ** 2 + posArray[idx + 2] ** 2);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                
                // Draw vertical color bar with height based on envelope
                const barHeight = Math.max(5, envelope * 30);
                phaseCtx.fillStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
                phaseCtx.fillRect(screenX - 1, stripY + stripHeight/2 - barHeight/2, 3, barHeight);
            }
            
            // Draw envelope outline
            phaseCtx.beginPath();
            phaseCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            phaseCtx.lineWidth = 1.5;
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const envelope = Math.sqrt(posArray[idx + 1] ** 2 + posArray[idx + 2] ** 2);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const envelopeHeight = envelope * 30;
                
                if (i === 0) phaseCtx.moveTo(screenX, stripY + stripHeight/2 - envelopeHeight/2);
                else phaseCtx.lineTo(screenX, stripY + stripHeight/2 - envelopeHeight/2);
            }
            phaseCtx.stroke();
            
            phaseCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const envelope = Math.sqrt(posArray[idx + 1] ** 2 + posArray[idx + 2] ** 2);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const envelopeHeight = envelope * 30;
                
                if (i === 0) phaseCtx.moveTo(screenX, stripY + stripHeight/2 + envelopeHeight/2);
                else phaseCtx.lineTo(screenX, stripY + stripHeight/2 + envelopeHeight/2);
            }
            phaseCtx.stroke();
            
            // Add labels
            phaseCtx.fillStyle = '#88ccff';
            phaseCtx.font = '11px sans-serif';
            phaseCtx.fillText('Phase: 0', 10, stripY - 10);
            phaseCtx.fillText('2œÄ', 370, stripY - 10);
            phaseCtx.fillText('Color = Phase Angle', 130, stripY + stripHeight + 25);
            
            // Draw phase arrow showing direction of propagation
            const arrowY = stripY + stripHeight + 50;
            phaseCtx.strokeStyle = '#88ccff';
            phaseCtx.fillStyle = '#88ccff';
            phaseCtx.lineWidth = 2;
            phaseCtx.beginPath();
            phaseCtx.moveTo(50, arrowY);
            phaseCtx.lineTo(350, arrowY);
            phaseCtx.stroke();
            phaseCtx.beginPath();
            phaseCtx.moveTo(350, arrowY);
            phaseCtx.lineTo(340, arrowY - 5);
            phaseCtx.lineTo(340, arrowY + 5);
            phaseCtx.closePath();
            phaseCtx.fill();
            phaseCtx.font = '10px sans-serif';
            phaseCtx.fillText('Wave Propagation ‚Üí', 140, arrowY - 10);
        }

        function animate() {
            requestAnimationFrame(animate);
            // NO TIME CAP - infinite smooth loop
            const elapsedTime = clock.getElapsedTime() * TIME_SCALE;
            updateWavePacket(elapsedTime);
            updateGrid(elapsedTime);
            draw2DProjections();
            controls.update();
            composer.render();
        }
    </script>
</body>
</html>
