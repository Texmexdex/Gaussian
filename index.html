<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Wave Packet</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            margin: 0; overflow: hidden;
            background: linear-gradient(135deg, #000000 0%, #0a0a1e 50%, #000000 100%);
            color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #container { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(15px);
            padding: 20px; border-radius: 12px;
            font-size: 14px; line-height: 1.6; z-index: 10; max-width: 480px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
        }
        #info code {
            font-family: 'Courier New', monospace; font-size: 15px;
            color: #88ccff; display: block;
            background: rgba(0, 100, 200, 0.1); padding: 12px;
            border-radius: 8px; margin-bottom: 12px;
            border-left: 3px solid #4488ff;
        }
        #info .label { color: #aabbcc; font-size: 13px; margin-bottom: 8px; }
        #info .controls {
            color: #6688aa; font-size: 11px; margin-top: 12px;
            padding-top: 12px; border-top: 1px solid rgba(100, 150, 255, 0.2);
        }
        @media (max-width: 768px) {
            #info { font-size: 12px; padding: 16px; max-width: calc(100vw - 40px); }
            #info code { font-size: 13px; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <code>Œ®(x,t) = A¬∑exp[-(x-vt)¬≤/4œÉ¬≤]¬∑exp[i(kx-œât)]</code>
        <div class="label">
            Gaussian wave packet with space-time warping visualization.
            The 3D helix shows real and imaginary components while the grid warps with the probability density.
        </div>
        <div class="controls">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-drag to pan</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>

    <script>
        const { EffectComposer, RenderPass, UnrealBloomPass } = THREE;
        let scene, camera, renderer, controls, composer, clock;
        let waveLine, lineGeometry, gridMesh, gridGeometry;

        const N_POINTS = 1500;
        const X_MIN = -40, X_MAX = 40, X_RANGE = X_MAX - X_MIN;
        const VELOCITY = 8.0, WAVENUMBER = 2.5, TIME_SCALE = 0.7;
        
        // Smooth cycling parameters instead of linear growth
        const AMPLITUDE_BASE = 2.0, AMPLITUDE_CYCLE_PERIOD = 25, AMPLITUDE_CYCLE_AMOUNT = 0.3;
        const WIDTH_BASE = 1.5, WIDTH_CYCLE_PERIOD = 20, WIDTH_CYCLE_AMOUNT = 0.4;
        const FREQ_BASE = WAVENUMBER * VELOCITY, FREQ_CYCLE_PERIOD = 18, FREQ_CYCLE_AMOUNT = 2.0;
        
        const GRID_SIZE = X_RANGE * 1.3, GRID_SEGMENTS = 60;
        const GRID_Y_POS = -4.0, MAX_WARP_DEPTH = 2.0, WARP_WIDTH_SCALE = 1.8;

        const wavePositions = new Float32Array(N_POINTS * 3);
        const waveColors = new Float32Array(N_POINTS * 3);
        let originalGridVertices = [];

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 20, 45);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x505070, 0.6));
            const light1 = new THREE.DirectionalLight(0x6688ff, 0.8);
            light1.position.set(20, 30, 20);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xff6688, 0.5);
            light2.position.set(-20, 20, -20);
            scene.add(light2);

            // Wave line
            lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(wavePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(waveColors, 3));
            const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
            waveLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(waveLine);

            // Grid
            gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);
            gridGeometry.rotateX(-Math.PI / 2);
            gridGeometry.translate(0, GRID_Y_POS, 0);

            const gridPosAttr = gridGeometry.attributes.position;
            for (let i = 0; i < gridPosAttr.count; i++) {
                originalGridVertices.push(new THREE.Vector3().fromBufferAttribute(gridPosAttr, i));
            }

            const gridMaterial = new THREE.MeshStandardMaterial({
                color: 0x3366cc, wireframe: true, roughness: 0.7, metalness: 0.3,
                transparent: true, opacity: 0.6, emissive: 0x112244, emissiveIntensity: 0.3
            });
            gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
            scene.add(gridMesh);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 15;
            controls.maxDistance = 120;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 1.4, 0.6, 0.3
            ));

            updateWavePacket(0);
            updateGrid(0);
            window.addEventListener('resize', onWindowResize, false);
        }

        function smoothCycle(time, period, amount) {
            return amount * Math.sin(2 * Math.PI * time / period);
        }

        function getEffectiveCenter(time) {
            const unwrappedCenter = VELOCITY * time;
            const offset = unwrappedCenter - X_MIN;
            const wrappedOffset = ((offset % X_RANGE) + X_RANGE) % X_RANGE;
            return X_MIN + wrappedOffset;
        }

        function updateWavePacket(time) {
            const posArray = wavePositions;
            const colorArray = waveColors;

            // Smooth cycling parameters
            const current_A = AMPLITUDE_BASE + smoothCycle(time, AMPLITUDE_CYCLE_PERIOD, AMPLITUDE_CYCLE_AMOUNT);
            const current_a = WIDTH_BASE + smoothCycle(time, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const current_omega = FREQ_BASE + smoothCycle(time, FREQ_CYCLE_PERIOD, FREQ_CYCLE_AMOUNT);
            const a_sq = current_a * current_a;
            const tempColor = new THREE.Color();
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < N_POINTS; i++) {
                const x = X_MIN + X_RANGE * (i / (N_POINTS - 1));
                
                // Smooth wrapping distance
                let dx = x - effective_center_x;
                if (Math.abs(dx) > X_RANGE / 2) {
                    dx = dx > 0 ? dx - X_RANGE : dx + X_RANGE;
                }

                const envelope = Math.exp(-(dx * dx) / (4 * a_sq));
                const phase = WAVENUMBER * x - current_omega * time;
                const realPart = Math.cos(phase);
                const imagPart = Math.sin(phase);

                const idx3 = i * 3;
                posArray[idx3] = x;
                posArray[idx3 + 1] = current_A * envelope * realPart;
                posArray[idx3 + 2] = current_A * envelope * imagPart;

                const hue = ((phase / (2 * Math.PI)) % 1.0 + 1) % 1.0;
                tempColor.setHSL(hue, 1.0, 0.65);
                colorArray[idx3] = tempColor.r;
                colorArray[idx3 + 1] = tempColor.g;
                colorArray[idx3 + 2] = tempColor.b;
            }

            lineGeometry.attributes.position.needsUpdate = true;
            lineGeometry.attributes.color.needsUpdate = true;
            lineGeometry.computeBoundingSphere();
        }

        function updateGrid(time) {
            const gridPosArray = gridGeometry.attributes.position.array;
            const current_a = WIDTH_BASE + smoothCycle(time, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const warp_width_sq = Math.pow(current_a * WARP_WIDTH_SCALE, 2);
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < originalGridVertices.length; i++) {
                const originalPos = originalGridVertices[i];
                const vertexX = originalPos.x;

                // Smooth wrapping distance
                let dx = vertexX - effective_center_x;
                if (Math.abs(dx) > X_RANGE / 2) {
                    dx = dx > 0 ? dx - X_RANGE : dx + X_RANGE;
                }

                const distSq = dx * dx;
                const warpFactor = Math.exp(-distSq / warp_width_sq);
                const warpY = -MAX_WARP_DEPTH * warpFactor;

                const idx = i * 3;
                gridPosArray[idx] = originalPos.x;
                gridPosArray[idx + 1] = originalPos.y + warpY;
                gridPosArray[idx + 2] = originalPos.z;
            }

            gridGeometry.attributes.position.needsUpdate = true;
            gridGeometry.computeVertexNormals();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            // NO TIME CAP - infinite smooth loop
            const elapsedTime = clock.getElapsedTime() * TIME_SCALE;
            updateWavePacket(elapsedTime);
            updateGrid(elapsedTime);
            controls.update();
            composer.render();
        }
    </script>
</body>
</html>
