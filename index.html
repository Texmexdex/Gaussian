<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warping Gaussian Wave Packet</title> {/* Updated Title */}
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute; top: 10px; left: 10px;
            background-color: rgba(0,0,0,0.7); padding: 15px; border-radius: 5px;
            font-size: 14px; line-height: 1.4; z-index: 10; max-width: 450px;
        }
        #info code { font-family: monospace; font-size: 1.1em; color: #f0f0f0; }
        #info .formula-line { margin-bottom: 10px; }
        #info .label { color: #aaa; font-size: 0.9em;}
        #info sup, #info sub { line-height: 0; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <div class="formula-line">
            <code>Ψ(x, t) = A(t) * e<sup>-(x-x₀(t))² / 4a(t)²</sup> * e<sup>i(kx - ω(t)t)</sup></code>
        </div>
        <div class="label">
            Warping Gaussian Wave Packet (Periodic)<br> {/* Updated Label */}
            Drag to rotate | Scroll to zoom | Right-drag to pan
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        const { EffectComposer } = THREE;
        const { RenderPass } = THREE;
        const { UnrealBloomPass } = THREE;

        let scene, camera, renderer, controls, composer;
        let waveLine, lineGeometry, gridMesh, gridGeometry;
        let clock;

        // --- Wave Simulation Parameters ---
        const N_POINTS = 1000;
        const X_MIN = -30;
        const X_MAX = 30;
        const X_RANGE = X_MAX - X_MIN; // Calculate range once
        const VELOCITY_v = 5.0;
        const WAVENUMBER_k = 2.0;
        const TIME_SCALE = 0.5;

        // --- Dynamic Wave Parameters ---
        const INITIAL_AMPLITUDE_A = 1.5;
        const AMPLITUDE_GROWTH_RATE = 0.2;
        const INITIAL_PACKET_WIDTH_a = 0.5;
        const SPREAD_RATE = 0.5;
        const INITIAL_FREQUENCY_omega = WAVENUMBER_k * VELOCITY_v * 0.5;
        const SPIN_UP_RATE = 5.0;

        // --- Grid Parameters ---
        const GRID_SIZE = X_RANGE * 1.2; // Make grid slightly larger than wave range
        const GRID_SEGMENTS = 50;
        const GRID_Y_POS = -3.0; // Position grid below the wave's center plane
        const MAX_WARP_DEPTH = 1.5; // How deep the grid dips
        const WARP_WIDTH_SCALE = 1.5; // How wide the warp effect is (relative to packet width 'a')

        // Buffers
        let wavePositionAttribute, waveColorAttribute;
        const wavePositions = new Float32Array(N_POINTS * 3);
        const waveColors = new Float32Array(N_POINTS * 3);

        let gridPositionAttribute;
        let originalGridVertices = []; // Store original grid vertex positions

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            console.log("Initializing Warping Packet...");

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 15, 35); // Adjusted view for grid
            camera.lookAt(scene.position); // Look towards the center

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            // Add a light source slightly above to help see the grid warp
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(0, 20, 10);
            scene.add(directionalLight);


            // === Wave Line Setup ===
            lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(wavePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(waveColors, 3));
            const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true });
            waveLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(waveLine);

            // === Grid Setup ===
            gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);
            // Rotate grid to be flat on XZ plane
            gridGeometry.rotateX(-Math.PI / 2);
            gridGeometry.translate(0, GRID_Y_POS, 0); // Move it down

            // Store original grid vertices
            originalGridVertices = [];
            const gridPosAttr = gridGeometry.attributes.position;
            for (let i = 0; i < gridPosAttr.count; i++) {
                originalGridVertices.push(new THREE.Vector3().fromBufferAttribute(gridPosAttr, i));
            }
            console.log(`Stored ${originalGridVertices.length} original grid vertices.`);

            const gridMaterial = new THREE.MeshStandardMaterial({
                color: 0x4444ff, // Bluish grid color
                wireframe: true,
                roughness: 0.8,
                metalness: 0.2
            });
            gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
            scene.add(gridMesh);

            // === Controls ===
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.target.set(0, 0, 0); // Set target slightly below wave plane

            // === Post-processing (Bloom) ===
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.3, // strength (adjusted slightly)
                0.5, // radius (adjusted slightly)
                0.2  // threshold (adjusted slightly)
            );
            composer.addPass(bloomPass);

            updateWavePacket(0); // Initial state
            updateGrid(0);       // Initial grid state
            window.addEventListener('resize', onWindowResize, false);
            console.log("Initialization complete.");
        }

        // Function to calculate the wrapped center position
        function getEffectiveCenter(time) {
            const unwrappedCenter = VELOCITY_v * time;
            // Modulo arithmetic to wrap around X_RANGE
            const offset = unwrappedCenter - X_MIN;
            const wrappedOffset = ((offset % X_RANGE) + X_RANGE) % X_RANGE; // Ensure positive result for negative offsets
            return X_MIN + wrappedOffset;
        }

        function updateWavePacket(time) {
            wavePositionAttribute = lineGeometry.getAttribute('position');
            waveColorAttribute = lineGeometry.getAttribute('color');
            const posArray = wavePositionAttribute.array;
            const colorArray = waveColorAttribute.array;

            const current_a = INITIAL_PACKET_WIDTH_a + SPREAD_RATE * time;
            const current_omega = INITIAL_FREQUENCY_omega + SPIN_UP_RATE * time;
            const current_A = INITIAL_AMPLITUDE_A + AMPLITUDE_GROWTH_RATE * time;
            const a_sq = current_a * current_a;
            const tempColor = new THREE.Color();

            // --- PERIODIC: Get effective center ---
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < N_POINTS; i++) {
                const x = X_MIN + (X_RANGE) * (i / (N_POINTS - 1));

                // --- PERIODIC: Use effective center for envelope calculation ---
                const dx = x - effective_center_x;
                const envelope = Math.exp(-(dx * dx) / (4 * a_sq));

                // Phase uses original time for continuous spin
                const phase = WAVENUMBER_k * x - current_omega * time;

                const realPart = Math.cos(phase);
                const imagPart = Math.sin(phase);

                const vx = x;
                const vy = current_A * envelope * realPart;
                const vz = current_A * envelope * imagPart;

                const idx3 = i * 3;
                posArray[idx3]     = vx;
                posArray[idx3 + 1] = vy;
                posArray[idx3 + 2] = vz;

                const hue = (phase / (2 * Math.PI)) % 1.0;
                tempColor.setHSL(hue < 0 ? hue + 1 : hue, 1.0, 0.7);
                colorArray[idx3]     = tempColor.r;
                colorArray[idx3 + 1] = tempColor.g;
                colorArray[idx3 + 2] = tempColor.b;
            }
            wavePositionAttribute.needsUpdate = true;
            waveColorAttribute.needsUpdate = true;
            lineGeometry.computeBoundingSphere();
        }

        function updateGrid(time) {
            gridPositionAttribute = gridGeometry.getAttribute('position');
            const gridPosArray = gridPositionAttribute.array;

            const current_a = INITIAL_PACKET_WIDTH_a + SPREAD_RATE * time;
            const warp_width_sq = Math.pow(current_a * WARP_WIDTH_SCALE, 2); // Warp width based on current packet width

            // --- PERIODIC: Get effective center for warp ---
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < originalGridVertices.length; i++) {
                const originalPos = originalGridVertices[i];
                const vertexX = originalPos.x;
                const vertexZ = originalPos.z; // Grid lies on XZ plane initially

                // Calculate horizontal distance squared from vertex to effective packet center
                const distSq = Math.pow(vertexX - effective_center_x, 2); // Only consider x distance for 1D warp

                // Gaussian warp function (strongest at center_x, falls off)
                const warpFactor = Math.exp(-distSq / warp_width_sq);
                const warpY = -MAX_WARP_DEPTH * warpFactor; // Negative to dip down

                const idx = i * 3;
                gridPosArray[idx]     = originalPos.x; // X remains original
                gridPosArray[idx + 1] = originalPos.y + warpY; // Y is original + warp
                gridPosArray[idx + 2] = originalPos.z; // Z remains original
            }

            gridPositionAttribute.needsUpdate = true;
            gridGeometry.computeVertexNormals(); // Important for lighting on the warped grid
        }


        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            composer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            // Limit time to prevent extreme parameters (adjust cap as needed)
            const timeCap = 20.0; // Increased cap slightly
            const elapsedTime = Math.min(clock.getElapsedTime() * TIME_SCALE, timeCap);

            updateWavePacket(elapsedTime);
            updateGrid(elapsedTime); // Update the grid every frame

            controls.update();
            composer.render();
        }
    </script>
</body>
</html>
