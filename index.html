<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Wave Packet</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            margin: 0; overflow: hidden;
            background: linear-gradient(135deg, #000000 0%, #0a0a1e 50%, #000000 100%);
            color: white; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #container { width: 100vw; height: 100vh; display: block; }
        #projections {
            position: absolute; bottom: 20px; right: 20px;
            display: grid; grid-template-columns: repeat(2, 200px);
            gap: 15px; z-index: 10;
        }
        .projection-view {
            width: 200px; height: 150px;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 10px; overflow: visible;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            position: relative;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            cursor: help;
        }
        .projection-view:hover {
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 6px 24px rgba(100, 150, 255, 0.4);
        }
        .projection-view canvas { width: 100%; height: 100%; display: block; }
        .projection-label {
            position: absolute; top: 5px; left: 8px;
            font-size: 11px; color: #88ccff; font-weight: 600;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
            pointer-events: none; z-index: 1;
        }
        .tooltip {
            position: absolute; right: 220px; top: 0;
            width: 280px; padding: 15px;
            background: rgba(10, 10, 30, 0.95); backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 10px;
            font-size: 12px; line-height: 1.6; color: #aabbcc;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 100;
        }
        .tooltip strong {
            color: #88ccff; display: block; margin-bottom: 8px;
            font-size: 13px;
        }
        .projection-view:hover .tooltip {
            opacity: 1;
        }
        @media (max-width: 1200px) {
            .tooltip { display: none; }
        }
        @media (max-width: 768px) {
            #projections { display: none; }
        }
        #info {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(15px);
            padding: 20px; border-radius: 12px;
            font-size: 14px; line-height: 1.6; z-index: 10; max-width: 480px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
        }
        #info code {
            font-family: 'Courier New', monospace; font-size: 15px;
            color: #88ccff; display: block;
            background: rgba(0, 100, 200, 0.1); padding: 12px;
            border-radius: 8px; margin-bottom: 12px;
            border-left: 3px solid #4488ff;
        }
        #info .label { color: #aabbcc; font-size: 13px; margin-bottom: 8px; }
        #info .controls {
            color: #6688aa; font-size: 11px; margin-top: 12px;
            padding-top: 12px; border-top: 1px solid rgba(100, 150, 255, 0.2);
        }
        @media (max-width: 768px) {
            #info { font-size: 12px; padding: 16px; max-width: calc(100vw - 40px); }
            #info code { font-size: 13px; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="projections">
        <div class="projection-view" data-tooltip="side">
            <div class="projection-label">Side View (XY)</div>
            <canvas id="sideCanvas"></canvas>
            <div class="tooltip">
                <strong>Side View (XY Plane)</strong><br>
                Shows the real component oscillating up and down. This is what you'd see if you looked at the wave from the side - a classic sine wave with a Gaussian envelope (peaks are highest in the middle, fade at edges).
            </div>
        </div>
        <div class="projection-view" data-tooltip="end">
            <div class="projection-label">End View (YZ)</div>
            <canvas id="endCanvas"></canvas>
            <div class="tooltip">
                <strong>End View (YZ Plane)</strong><br>
                Looking through the wave from one end, you see a circular pattern. The real (Y) and imaginary (Z) components trace out circles, showing the wave's rotation in complex space. The envelope makes it look like nested circles.
            </div>
        </div>
        <div class="projection-view" data-tooltip="top">
            <div class="projection-label">Top View (XZ)</div>
            <canvas id="topCanvas"></canvas>
            <div class="tooltip">
                <strong>Top View (XZ Plane)</strong><br>
                Shows the imaginary component oscillating forward and back. This is 90¬∞ out of phase with the side view, demonstrating the complex nature of the quantum wave function.
            </div>
        </div>
        <div class="projection-view" data-tooltip="phase">
            <div class="projection-label">Phase Spectrum</div>
            <canvas id="phaseCanvas"></canvas>
            <div class="tooltip">
                <strong>Phase Visualization</strong><br>
                Colors represent the wave's phase: œÜ = kx - œât. As the phase cycles from 0 to 2œÄ, colors flow through the spectrum (red ‚Üí yellow ‚Üí green ‚Üí cyan ‚Üí blue ‚Üí magenta ‚Üí red). This shows where each point is in its oscillation cycle and is crucial for quantum interference.
            </div>
        </div>
        <div class="projection-view" data-tooltip="probability">
            <div class="projection-label">Probability |Œ®|¬≤</div>
            <canvas id="probabilityCanvas"></canvas>
            <div class="tooltip">
                <strong>Probability Density</strong><br>
                Shows |Œ®|¬≤ - the probability of finding the particle at each position. This is what you'd measure in an experiment. The Gaussian shape shows the particle is most likely near the center of the packet.
            </div>
        </div>
        <div class="projection-view" data-tooltip="complex">
            <div class="projection-label">Complex Plane</div>
            <canvas id="complexCanvas"></canvas>
            <div class="tooltip">
                <strong>Complex Plane (Argand Diagram)</strong><br>
                Plots Re(Œ®) vs Im(Œ®) as a parametric curve. The 3D helix "unwrapped" into 2D complex space. The spiral shows how the wave rotates in the complex plane, with radius determined by the Gaussian envelope.
            </div>
        </div>
        <div class="projection-view" data-tooltip="momentum">
            <div class="projection-label">Momentum Space</div>
            <canvas id="momentumCanvas"></canvas>
            <div class="tooltip">
                <strong>Momentum Space (Fourier Transform)</strong><br>
                The wave packet in momentum/frequency domain. By Heisenberg's uncertainty principle, a narrow position spread (Gaussian) gives a wide momentum spread. Shows wave-particle duality: localized in space = spread in momentum.
            </div>
        </div>
        <div class="projection-view" data-tooltip="spacetime">
            <div class="projection-label">Spacetime</div>
            <canvas id="spacetimeCanvas"></canvas>
            <div class="tooltip">
                <strong>Spacetime Diagram</strong><br>
                Position (x) vs Time showing the wave packet's worldline. The diagonal streak shows the packet moving at constant velocity. Color shows phase evolution. This is how the wave packet travels through spacetime.
            </div>
        </div>
    </div>
    
    <div id="info">
        <code>Œ®(x,t) = A¬∑exp[-(x-vt)¬≤/4œÉ¬≤]¬∑exp[i(kx-œât)]</code>
        <div class="label">
            Gaussian wave packet with space-time warping visualization.
            The 3D helix shows real and imaginary components while the grid warps with the probability density.
        </div>
        <div class="controls">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-drag to pan</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>

    <script>
        const { EffectComposer, RenderPass, UnrealBloomPass } = THREE;
        let scene, camera, renderer, controls, composer, clock;
        let waveLine, lineGeometry, gridMesh, gridGeometry;
        let sideCtx, endCtx, topCtx, phaseCtx, probabilityCtx, complexCtx, momentumCtx, spacetimeCtx;
        let spacetimeHistory = [];

        const N_POINTS = 1500;
        const X_MIN = -40, X_MAX = 40, X_RANGE = X_MAX - X_MIN;
        const VELOCITY = 8.0, WAVENUMBER = 2.5, TIME_SCALE = 0.7;
        
        // Smooth cycling parameters instead of linear growth
        const AMPLITUDE_BASE = 2.0, AMPLITUDE_CYCLE_PERIOD = 25, AMPLITUDE_CYCLE_AMOUNT = 0.3;
        const WIDTH_BASE = 1.5, WIDTH_CYCLE_PERIOD = 20, WIDTH_CYCLE_AMOUNT = 0.4;
        const FREQ_BASE = WAVENUMBER * VELOCITY, FREQ_CYCLE_PERIOD = 18, FREQ_CYCLE_AMOUNT = 2.0;
        
        const GRID_SIZE = X_RANGE * 1.3, GRID_SEGMENTS = 60;
        const GRID_Y_POS = -4.0, MAX_WARP_DEPTH = 2.0, WARP_WIDTH_SCALE = 1.8;

        const wavePositions = new Float32Array(N_POINTS * 3);
        const waveColors = new Float32Array(N_POINTS * 3);
        let originalGridVertices = [];

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            
            // Setup 2D projection canvases
            const sideCanvas = document.getElementById('sideCanvas');
            const endCanvas = document.getElementById('endCanvas');
            const topCanvas = document.getElementById('topCanvas');
            const phaseCanvas = document.getElementById('phaseCanvas');
            const probabilityCanvas = document.getElementById('probabilityCanvas');
            const complexCanvas = document.getElementById('complexCanvas');
            const momentumCanvas = document.getElementById('momentumCanvas');
            const spacetimeCanvas = document.getElementById('spacetimeCanvas');
            
            [sideCanvas, endCanvas, topCanvas, phaseCanvas, probabilityCanvas, complexCanvas, momentumCanvas, spacetimeCanvas].forEach(canvas => {
                canvas.width = 400;
                canvas.height = 300;
            });
            
            sideCtx = sideCanvas.getContext('2d');
            endCtx = endCanvas.getContext('2d');
            topCtx = topCanvas.getContext('2d');
            phaseCtx = phaseCanvas.getContext('2d');
            probabilityCtx = probabilityCanvas.getContext('2d');
            complexCtx = complexCanvas.getContext('2d');
            momentumCtx = momentumCanvas.getContext('2d');
            spacetimeCtx = spacetimeCanvas.getContext('2d');
            
            // Initialize spacetime history buffer
            spacetimeHistory = [];
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 20, 45);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0x505070, 0.6));
            const light1 = new THREE.DirectionalLight(0x6688ff, 0.8);
            light1.position.set(20, 30, 20);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xff6688, 0.5);
            light2.position.set(-20, 20, -20);
            scene.add(light2);

            // Wave line
            lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(wavePositions, 3));
            lineGeometry.setAttribute('color', new THREE.BufferAttribute(waveColors, 3));
            const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
            waveLine = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(waveLine);

            // Grid
            gridGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEGMENTS, GRID_SEGMENTS);
            gridGeometry.rotateX(-Math.PI / 2);
            gridGeometry.translate(0, GRID_Y_POS, 0);

            const gridPosAttr = gridGeometry.attributes.position;
            for (let i = 0; i < gridPosAttr.count; i++) {
                originalGridVertices.push(new THREE.Vector3().fromBufferAttribute(gridPosAttr, i));
            }

            const gridMaterial = new THREE.MeshStandardMaterial({
                color: 0x3366cc, wireframe: true, roughness: 0.7, metalness: 0.3,
                transparent: true, opacity: 0.6, emissive: 0x112244, emissiveIntensity: 0.3
            });
            gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
            scene.add(gridMesh);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 15;
            controls.maxDistance = 120;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 1.4, 0.6, 0.3
            ));

            updateWavePacket(0);
            updateGrid(0);
            window.addEventListener('resize', onWindowResize, false);
        }

        function smoothCycle(time, period, amount) {
            return amount * Math.sin(2 * Math.PI * time / period);
        }

        function getEffectiveCenter(time) {
            const unwrappedCenter = VELOCITY * time;
            const offset = unwrappedCenter - X_MIN;
            const wrappedOffset = ((offset % X_RANGE) + X_RANGE) % X_RANGE;
            return X_MIN + wrappedOffset;
        }

        function updateWavePacket(time) {
            const posArray = wavePositions;
            const colorArray = waveColors;

            // Smooth cycling parameters
            const current_A = AMPLITUDE_BASE + smoothCycle(time, AMPLITUDE_CYCLE_PERIOD, AMPLITUDE_CYCLE_AMOUNT);
            const current_a = WIDTH_BASE + smoothCycle(time, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const current_omega = FREQ_BASE + smoothCycle(time, FREQ_CYCLE_PERIOD, FREQ_CYCLE_AMOUNT);
            const a_sq = current_a * current_a;
            const tempColor = new THREE.Color();
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < N_POINTS; i++) {
                const x = X_MIN + X_RANGE * (i / (N_POINTS - 1));
                
                // Smooth wrapping distance
                let dx = x - effective_center_x;
                if (Math.abs(dx) > X_RANGE / 2) {
                    dx = dx > 0 ? dx - X_RANGE : dx + X_RANGE;
                }

                const envelope = Math.exp(-(dx * dx) / (4 * a_sq));
                const phase = WAVENUMBER * x - current_omega * time;
                const realPart = Math.cos(phase);
                const imagPart = Math.sin(phase);

                const idx3 = i * 3;
                posArray[idx3] = x;
                posArray[idx3 + 1] = current_A * envelope * realPart;
                posArray[idx3 + 2] = current_A * envelope * imagPart;

                const hue = ((phase / (2 * Math.PI)) % 1.0 + 1) % 1.0;
                tempColor.setHSL(hue, 1.0, 0.65);
                colorArray[idx3] = tempColor.r;
                colorArray[idx3 + 1] = tempColor.g;
                colorArray[idx3 + 2] = tempColor.b;
            }

            lineGeometry.attributes.position.needsUpdate = true;
            lineGeometry.attributes.color.needsUpdate = true;
            lineGeometry.computeBoundingSphere();
        }

        function updateGrid(time) {
            const gridPosArray = gridGeometry.attributes.position.array;
            const current_a = WIDTH_BASE + smoothCycle(time, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const warp_width_sq = Math.pow(current_a * WARP_WIDTH_SCALE, 2);
            const effective_center_x = getEffectiveCenter(time);

            for (let i = 0; i < originalGridVertices.length; i++) {
                const originalPos = originalGridVertices[i];
                const vertexX = originalPos.x;

                // Smooth wrapping distance
                let dx = vertexX - effective_center_x;
                if (Math.abs(dx) > X_RANGE / 2) {
                    dx = dx > 0 ? dx - X_RANGE : dx + X_RANGE;
                }

                const distSq = dx * dx;
                const warpFactor = Math.exp(-distSq / warp_width_sq);
                const warpY = -MAX_WARP_DEPTH * warpFactor;

                const idx = i * 3;
                gridPosArray[idx] = originalPos.x;
                gridPosArray[idx + 1] = originalPos.y + warpY;
                gridPosArray[idx + 2] = originalPos.z;
            }

            gridGeometry.attributes.position.needsUpdate = true;
            gridGeometry.computeVertexNormals();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function draw2DProjections() {
            const posArray = wavePositions;
            const colorArray = waveColors;
            
            // Clear canvases
            sideCtx.fillStyle = '#000';
            sideCtx.fillRect(0, 0, 400, 300);
            endCtx.fillStyle = '#000';
            endCtx.fillRect(0, 0, 400, 300);
            topCtx.fillStyle = '#000';
            topCtx.fillRect(0, 0, 400, 300);
            
            // Draw grid lines
            const drawGrid = (ctx) => {
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 40, 0);
                    ctx.lineTo(i * 40, 300);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * 30);
                    ctx.lineTo(400, i * 30);
                    ctx.stroke();
                }
            };
            drawGrid(sideCtx);
            drawGrid(endCtx);
            drawGrid(topCtx);
            
            // Draw center lines
            const drawCenterLines = (ctx) => {
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, 150);
                ctx.lineTo(400, 150);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(200, 0);
                ctx.lineTo(200, 300);
                ctx.stroke();
            };
            drawCenterLines(sideCtx);
            drawCenterLines(endCtx);
            drawCenterLines(topCtx);
            
            // Scale factors for visualization
            const xScale = 400 / X_RANGE;
            const yScale = 60;
            const zScale = 60;
            
            // Side view (XY) - shows oscillating wave with Gaussian envelope
            sideCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const y = posArray[idx + 1];
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const screenY = 150 - y * yScale;
                
                if (i === 0) sideCtx.moveTo(screenX, screenY);
                else sideCtx.lineTo(screenX, screenY);
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                sideCtx.strokeStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
            }
            sideCtx.lineWidth = 2;
            sideCtx.stroke();
            
            // End view (YZ) - shows circular/coroidal pattern
            endCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const y = posArray[idx + 1];
                const z = posArray[idx + 2];
                
                const screenX = 200 + z * zScale;
                const screenY = 150 - y * yScale;
                
                if (i === 0) endCtx.moveTo(screenX, screenY);
                else endCtx.lineTo(screenX, screenY);
            }
            endCtx.strokeStyle = '#88ccff';
            endCtx.lineWidth = 2;
            endCtx.stroke();
            
            // Draw points to show the circular pattern better
            for (let i = 0; i < N_POINTS; i += 20) {
                const idx = i * 3;
                const y = posArray[idx + 1];
                const z = posArray[idx + 2];
                
                const screenX = 200 + z * zScale;
                const screenY = 150 - y * yScale;
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                
                endCtx.fillStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
                endCtx.beginPath();
                endCtx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                endCtx.fill();
            }
            
            // Top view (XZ) - shows another oscillating wave
            topCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const z = posArray[idx + 2];
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const screenY = 150 - z * zScale;
                
                if (i === 0) topCtx.moveTo(screenX, screenY);
                else topCtx.lineTo(screenX, screenY);
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                topCtx.strokeStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
            }
            topCtx.lineWidth = 2;
            topCtx.stroke();
            
            // Phase spectrum view - shows color flow across the wave
            phaseCtx.fillStyle = '#000';
            phaseCtx.fillRect(0, 0, 400, 300);
            drawGrid(phaseCtx);
            
            // Draw phase as a color gradient strip
            const stripHeight = 80;
            const stripY = 110;
            
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const envelope = Math.sqrt(posArray[idx + 1] ** 2 + posArray[idx + 2] ** 2);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                
                // Draw vertical color bar with height based on envelope
                const barHeight = Math.max(5, envelope * 30);
                phaseCtx.fillStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
                phaseCtx.fillRect(screenX - 1, stripY + stripHeight/2 - barHeight/2, 3, barHeight);
            }
            
            // Draw envelope outline
            phaseCtx.beginPath();
            phaseCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            phaseCtx.lineWidth = 1.5;
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const envelope = Math.sqrt(posArray[idx + 1] ** 2 + posArray[idx + 2] ** 2);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const envelopeHeight = envelope * 30;
                
                if (i === 0) phaseCtx.moveTo(screenX, stripY + stripHeight/2 - envelopeHeight/2);
                else phaseCtx.lineTo(screenX, stripY + stripHeight/2 - envelopeHeight/2);
            }
            phaseCtx.stroke();
            
            phaseCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const envelope = Math.sqrt(posArray[idx + 1] ** 2 + posArray[idx + 2] ** 2);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const envelopeHeight = envelope * 30;
                
                if (i === 0) phaseCtx.moveTo(screenX, stripY + stripHeight/2 + envelopeHeight/2);
                else phaseCtx.lineTo(screenX, stripY + stripHeight/2 + envelopeHeight/2);
            }
            phaseCtx.stroke();
            
            // Add labels
            phaseCtx.fillStyle = '#88ccff';
            phaseCtx.font = '11px sans-serif';
            phaseCtx.fillText('Phase: 0', 10, stripY - 10);
            phaseCtx.fillText('2œÄ', 370, stripY - 10);
            phaseCtx.fillText('Color = Phase Angle', 130, stripY + stripHeight + 25);
            
            // Draw phase arrow showing direction of propagation
            const arrowY = stripY + stripHeight + 50;
            phaseCtx.strokeStyle = '#88ccff';
            phaseCtx.fillStyle = '#88ccff';
            phaseCtx.lineWidth = 2;
            phaseCtx.beginPath();
            phaseCtx.moveTo(50, arrowY);
            phaseCtx.lineTo(350, arrowY);
            phaseCtx.stroke();
            phaseCtx.beginPath();
            phaseCtx.moveTo(350, arrowY);
            phaseCtx.lineTo(340, arrowY - 5);
            phaseCtx.lineTo(340, arrowY + 5);
            phaseCtx.closePath();
            phaseCtx.fill();
            phaseCtx.font = '10px sans-serif';
            phaseCtx.fillText('Wave Propagation ‚Üí', 140, arrowY - 10);
            
            // Probability Density |Œ®|¬≤
            probabilityCtx.fillStyle = '#000';
            probabilityCtx.fillRect(0, 0, 400, 300);
            drawGrid(probabilityCtx);
            drawCenterLines(probabilityCtx);
            
            probabilityCtx.beginPath();
            probabilityCtx.fillStyle = 'rgba(100, 255, 150, 0.3)';
            probabilityCtx.moveTo(0, 300);
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const y = posArray[idx + 1];
                const z = posArray[idx + 2];
                const probDensity = (y * y + z * z) / (AMPLITUDE_BASE * AMPLITUDE_BASE);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const screenY = 150 - probDensity * 100;
                
                if (i === 0) probabilityCtx.moveTo(screenX, 300);
                probabilityCtx.lineTo(screenX, screenY);
            }
            probabilityCtx.lineTo(400, 300);
            probabilityCtx.closePath();
            probabilityCtx.fill();
            
            probabilityCtx.beginPath();
            probabilityCtx.strokeStyle = '#44ff88';
            probabilityCtx.lineWidth = 2;
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const x = posArray[idx];
                const y = posArray[idx + 1];
                const z = posArray[idx + 2];
                const probDensity = (y * y + z * z) / (AMPLITUDE_BASE * AMPLITUDE_BASE);
                
                const screenX = ((x - X_MIN) / X_RANGE) * 400;
                const screenY = 150 - probDensity * 100;
                
                if (i === 0) probabilityCtx.moveTo(screenX, screenY);
                else probabilityCtx.lineTo(screenX, screenY);
            }
            probabilityCtx.stroke();
            
            probabilityCtx.fillStyle = '#88ffbb';
            probabilityCtx.font = '11px sans-serif';
            probabilityCtx.fillText('|Œ®|¬≤', 10, 20);
            
            // Complex Plane (Argand Diagram)
            complexCtx.fillStyle = '#000';
            complexCtx.fillRect(0, 0, 400, 300);
            drawGrid(complexCtx);
            drawCenterLines(complexCtx);
            
            const maxAmplitude = AMPLITUDE_BASE * 1.5;
            const scale = 100 / maxAmplitude;
            
            complexCtx.beginPath();
            for (let i = 0; i < N_POINTS; i++) {
                const idx = i * 3;
                const realPart = posArray[idx + 1];
                const imagPart = posArray[idx + 2];
                
                const screenX = 200 + realPart * scale;
                const screenY = 150 - imagPart * scale;
                
                if (i === 0) complexCtx.moveTo(screenX, screenY);
                else complexCtx.lineTo(screenX, screenY);
            }
            complexCtx.strokeStyle = '#ff88ff';
            complexCtx.lineWidth = 2;
            complexCtx.stroke();
            
            // Draw points along the spiral
            for (let i = 0; i < N_POINTS; i += 30) {
                const idx = i * 3;
                const realPart = posArray[idx + 1];
                const imagPart = posArray[idx + 2];
                
                const screenX = 200 + realPart * scale;
                const screenY = 150 - imagPart * scale;
                
                const r = colorArray[idx];
                const g = colorArray[idx + 1];
                const b = colorArray[idx + 2];
                
                complexCtx.fillStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
                complexCtx.beginPath();
                complexCtx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                complexCtx.fill();
            }
            
            complexCtx.fillStyle = '#ff88ff';
            complexCtx.font = '11px sans-serif';
            complexCtx.fillText('Re(Œ®)', 360, 155);
            complexCtx.fillText('Im(Œ®)', 205, 20);
            
            // Momentum Space (Fourier Transform approximation)
            momentumCtx.fillStyle = '#000';
            momentumCtx.fillRect(0, 0, 400, 300);
            drawGrid(momentumCtx);
            drawCenterLines(momentumCtx);
            
            // Approximate momentum space: wider in momentum when narrow in position
            const current_a = WIDTH_BASE + smoothCycle(elapsedTime, WIDTH_CYCLE_PERIOD, WIDTH_CYCLE_AMOUNT);
            const momentum_width = 1.0 / current_a; // Uncertainty principle
            const k_center = WAVENUMBER;
            
            momentumCtx.beginPath();
            momentumCtx.fillStyle = 'rgba(255, 150, 100, 0.3)';
            momentumCtx.moveTo(0, 300);
            for (let i = 0; i < 200; i++) {
                const k = k_center - 5 + (i / 200) * 10;
                const momentum_envelope = Math.exp(-Math.pow(k - k_center, 2) / (2 * momentum_width * momentum_width));
                
                const screenX = (i / 200) * 400;
                const screenY = 150 - momentum_envelope * 120;
                
                if (i === 0) momentumCtx.moveTo(screenX, 300);
                momentumCtx.lineTo(screenX, screenY);
            }
            momentumCtx.lineTo(400, 300);
            momentumCtx.closePath();
            momentumCtx.fill();
            
            momentumCtx.beginPath();
            momentumCtx.strokeStyle = '#ff8844';
            momentumCtx.lineWidth = 2;
            for (let i = 0; i < 200; i++) {
                const k = k_center - 5 + (i / 200) * 10;
                const momentum_envelope = Math.exp(-Math.pow(k - k_center, 2) / (2 * momentum_width * momentum_width));
                
                const screenX = (i / 200) * 400;
                const screenY = 150 - momentum_envelope * 120;
                
                if (i === 0) momentumCtx.moveTo(screenX, screenY);
                else momentumCtx.lineTo(screenX, screenY);
            }
            momentumCtx.stroke();
            
            momentumCtx.fillStyle = '#ffaa66';
            momentumCtx.font = '11px sans-serif';
            momentumCtx.fillText('|Œ¶(k)|¬≤', 10, 20);
            momentumCtx.fillText('Narrow in x ‚Üí Wide in k', 100, 280);
            
            // Spacetime Diagram
            spacetimeCtx.fillStyle = '#000';
            spacetimeCtx.fillRect(0, 0, 400, 300);
            drawGrid(spacetimeCtx);
            
            // Store current wave state in history
            const effective_center_x = getEffectiveCenter(elapsedTime);
            spacetimeHistory.push({
                time: elapsedTime,
                center: effective_center_x,
                positions: new Float32Array(posArray),
                colors: new Float32Array(colorArray)
            });
            
            // Keep only last 100 time steps
            if (spacetimeHistory.length > 100) spacetimeHistory.shift();
            
            // Draw spacetime history
            const timeScale = 300 / 30; // 30 time units fit in height
            const oldestTime = spacetimeHistory[0].time;
            
            for (let t = 0; t < spacetimeHistory.length; t++) {
                const snapshot = spacetimeHistory[t];
                const relativeTime = snapshot.time - oldestTime;
                const screenY = 300 - relativeTime * timeScale;
                
                if (screenY < 0) continue;
                
                for (let i = 0; i < N_POINTS; i += 10) {
                    const idx = i * 3;
                    const x = snapshot.positions[idx];
                    const amplitude = Math.sqrt(snapshot.positions[idx + 1] ** 2 + snapshot.positions[idx + 2] ** 2);
                    
                    const screenX = ((x - X_MIN) / X_RANGE) * 400;
                    
                    const r = snapshot.colors[idx];
                    const g = snapshot.colors[idx + 1];
                    const b = snapshot.colors[idx + 2];
                    const alpha = amplitude / AMPLITUDE_BASE * 0.8;
                    
                    spacetimeCtx.fillStyle = `rgba(${r*255}, ${g*255}, ${b*255}, ${alpha})`;
                    spacetimeCtx.fillRect(screenX - 1, screenY - 1, 2, 2);
                }
            }
            
            spacetimeCtx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
            spacetimeCtx.lineWidth = 1;
            spacetimeCtx.beginPath();
            spacetimeCtx.moveTo(0, 150);
            spacetimeCtx.lineTo(400, 150);
            spacetimeCtx.stroke();
            
            spacetimeCtx.fillStyle = '#88ccff';
            spacetimeCtx.font = '11px sans-serif';
            spacetimeCtx.fillText('Position ‚Üí', 320, 290);
            spacetimeCtx.save();
            spacetimeCtx.translate(15, 150);
            spacetimeCtx.rotate(-Math.PI / 2);
            spacetimeCtx.fillText('Time ‚Üí', 0, 0);
            spacetimeCtx.restore();
        }
        
        let elapsedTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            // NO TIME CAP - infinite smooth loop
            elapsedTime = clock.getElapsedTime() * TIME_SCALE;
            updateWavePacket(elapsedTime);
            updateGrid(elapsedTime);
            draw2DProjections();
            controls.update();
            composer.render();
        }
    </script>
</body>
</html>
